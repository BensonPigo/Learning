好的，這是在您提供的內容基礎上，重新排版後的 Markdown 格式。我將其分成了三個主要區塊，並使用標題、清單和分隔線來提升可讀性。

-----

### 1\. 詳細元件關係圖 (跨模組)

這張圖展示了在一個網購系統中，至少需要三個獨立的模組：Ordering (訂單)、Inventory (庫存) 和 Payment (付款)。它們之間是完全解耦的，唯一的溝通方式是透過事件匯流排 (Event Bus)。

```plaintext
+-------------------------------------------------------------------------------------------------------+
|                                 Infrastructure Layer                                                  |
|               +----------------------------------------------+                                        |
|               |       Event Bus (e.g., RabbitMQ, Azure SB)   |                                        |
|               |----------------------------------------------|                                        |
|               |     負責在不同模組之間可靠地傳遞「事件」訊息   |                                        |
|               +----------------------------------------------+                                        |
+-------------------------------------------------------------------------------------------------------+
        ^                 ^                  ^                  ^
        | (發布事件)        | (訂閱事件)         | (發布事件)         | (訂閱事件)
        v                 v                  v                  v
+------------------+    +------------------+    +------------------+    +------------------+
| Ordering Module  |    | Inventory Module |    |  Payment Module  |    | Customer Module  |
|------------------|    |------------------|    |------------------|    |------------------|
| App:             |    | App:             |    | App:             |    | App:             |
| IOrderService    |    | IStockService    |    | IPaymentService  |    | ...              |
| OrderService     |    | StockService     |    | PaymentService   |    |                  |
| ✨OrderProcessManager✨|    | StockEventHandler  |    | PaymentEventHandler|    |                  |
| (Saga - 協調者)  |    | (監聽者)         |    | (監聽者)         |    |                  |
|------------------|    |------------------|    |------------------|    |------------------|
| Core:            |    | Core:            |    | Core:            |    | Core:            |
| Order (Entity)   |    | StockItem(Entity)|    | Payment (Entity) |    | ...              |
| OrderPlacedEvent |    | StockReservedEvent|    | PaymentProcessed |    |                  |
| ...              |    | ...              |    | ...              |    |                  |
+------------------+    +------------------+    +------------------+    +------------------+
```

#### 解讀：

  * **模組獨立**：Ordering, Inventory, Payment 等都是獨立的業務單元，各自擁有自己的 Core, Application, Infrastructure 三層。
  * **事件驅動**：模組之間不直接呼叫。Ordering 模組不知道 Inventory 模組的存在。它只知道向 Event Bus 發布一個 `OrderPlaced` 事件。
  * **Saga 作為協調者**：`OrderProcessManager` (Saga) 位於流程的擁有者 (Ordering) 模組的 Application 層。它負責監聽整個流程中由其他模組發布的事件（如 `StockReserved`），並根據這些事件來決定下一步該做什麼。

-----

### 2\. 請求流程圖 (時序圖) - 成功路徑 ("Happy Path")

這張圖展示了當使用者點擊「送出訂單」後，一個成功的請求是如何在各個模組之間流動的。

<img width="1314" height="886" alt="成功路徑時序圖" src="https://github.com/user-attachments/assets/474de015-bfa8-4ba5-a482-e1c9bf65af7b" />

-----

### 3\. 請求流程圖 (時序圖) - 失敗與補償路徑

假設庫存不足。
<img width="1435" height="762" alt="失敗與補償路徑時序圖" src="https://github.com/user-attachments/assets/f3dc94d3-bd9c-4bf9-8ff4-66cf21051dcb" />

#### 解讀失敗路徑：

1.  當 Inventory 模組發現庫存不足時，它會發布一個失敗事件 (`StockReservationFailed`)。
2.  位於 Ordering 模組的 `OrderProcessManager` (Saga) 監聽到這個失敗事件。
3.  它知道整個流程已經不可能成功了，於是它必須執行**補償操作 (Compensating Transaction)**，也就是回頭去取消它在第一步建立的 Pending 訂單，以確保系統的資料最終是一致的。
